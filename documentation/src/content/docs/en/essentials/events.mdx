---
title: Events
description: We explain what event units are, how to use them, and how to work with them.
redirectFrom:
  - /docs/essentials/events
  - /essentials/events
  - /en/explanation/events
  - /explanation/events
---

import SideBySide from "@components/SideBySide/SideBySide.astro";

# Events (#events)

Although effector has three main concepts — [events](/en/api/effector/Event), [stores](/en/api/effector/Store), and [effects](/en/api/effector/Effect) — it is [events](/en/api/effector/Event) that can be called the foundation for how your application works. The entire frontend is built atop an event-driven model, and you have most likely already worked with events in JavaScript, for example via `addEventListener` or React handlers like `onClick`. They are all events we can subscribe to, and effector lets us create our own event with [`createEvent`](/en/api/effector/createEvent) and subscribe to it:

<SideBySide>

<Fragment slot="left">

```ts data-height="full"
let counter = 10;

document.addEventListener("click", () => {
  counter = 13;
});
```

</Fragment>

  <Fragment slot="right">

```ts data-height="full"
import { createEvent, createStore, sample } from "effector";

const $counter = createStore(10);

const click = createEvent();

sample({
  clock: click,
  fn: () => 13,
  target: $counter,
});
```

</Fragment>

</SideBySide>

:::info{title="Effector events"}
[Events](/en/api/effector/Event) in effector are not the same as DOM events; this example only demonstrates a similar concept.
:::

## Why we need events (#why-we-need-events)

All effector code is built on top of [events](/en/api/effector/Event). For example, if you pass a store to the [`clock`](/en/api/effector/sample#clock-argument) argument of [`sample`](/en/api/effector/sample), that [`sample`](/en/api/effector/sample) will be triggered whenever the [`updates`](/en/api/effector/Store#properties-updates) event of the store fires:

<SideBySide>

<Fragment slot="left">

```ts "clock: $someStore"
// this code is equivalent to the example on the right
import { createStore, sample } from "effector";

const $someStore = createStore();
sample({
  clock: $someStore,
  // ...
});
```

</Fragment>

  <Fragment slot="right">

```ts "clock: $someStore.updates"
// this code is equivalent to the example on the left
import { createStore, sample } from "effector";

const $someStore = createStore();
sample({
  clock: $someStore.updates,
  // ...
});
```

</Fragment>

</SideBySide>

An [event](/en/api/effector/Event) by itself simply states the fact that something has happened: a button click, data refresh, notification display, and so on. Events pass information along and notify their subscribers that they have been triggered.

To make it easier to reason about your code, treat everything the user can interact with and the inner parts of your business logic as events. Besides UI-oriented events like `buttonClicked` or `inputChanged`, you can also have events tied to data updates `valueUpdated` or exceptional situations `errorOccurred`.

For example, [effects](/en/api/effector/Effect) have built-in events [`done`](/en/api/effector/Effect#properties-done) and [`fail`](/en/api/effector/Effect#properties-fail) that run when an effect finishes successfully or throws an error. [Stores](/en/api/effector/Store) have the [`updates`](/en/api/effector/Store#properties-updates) event that is triggered whenever the store changes.

Events also help you keep the code loosely coupled, which simplifies maintenance and testing.

:::tip{title="Why events matter"}
On the [How to think in the effector paradigm](/en/resources/mindset) page we dig deeper into why events are important and the benefits they bring.
:::

### How to use events (#how-to-use-events)

You can create events with [`createEvent`](/en/api/effector/createEvent) and subscribe to them with [`sample`](/en/api/effector/sample):

```ts
import { sample, createEvent } from "effector";

const event = createEvent();

sample({
  clock: event,
  // ...
});
```

:::tip{title="What is sample"}
If you are not familiar with [`sample`](/en/api/effector/sample), in the examples above it subscribes to the event passed via [`clock`](/en/api/effector/sample#clock-argument) and runs the described chain of logic whenever the event triggers. You can learn more on the [Unit composition](/en/essentials/unit-composition) page.
:::

With events you can [update stores](/en/essentials/manage-states#store-updates), trigger [effects](/en/api/effector/Effect), or fire other events:

```ts
import { sample, createStore, createEvent } from "effector";

const $clicksCount = createStore(0);

const userClicked = createEvent<void>();

// update the counter store
sample({
  clock: userClicked,
  source: $clicksCount,
  fn: (clicksCount) => clicksCount + 1,
  target: $clicksCount,
});

userClicked();
```

```ts
import { createEvent, createEffect, sample } from "effector";

const startFetch = createEvent<string>();
const fetchFx = createEffect((url: string) => {
  // ...
});

// trigger an effect
sample({
  clock: startFetch,
  target: fetchFx,
});

startFetch("/fake-api/users");
```

An important characteristic of events is that they can accept only one argument; additional arguments are ignored. Use an object if you need to pass multiple values:

```ts
const event = createEvent<{ a: number; b: string }>();

event({
  a: 1,
  b: "string",
});
```

## Event calling (#event-calling)

You can trigger an event in two ways: imperatively or declaratively.

The **imperative** approach is a familiar one, where you call an event as a function (`event()`). This is how you will typically fire events from the UI by passing a handler to `onClick`, `onChange`, and so on:

```tsx "const click = useUnit(clickHappened);" "click()" "useUnit"
import { createEvent } from "effector";
// you can use any framework and its integration package
import { useUnit } from "effector-react";

const clickHappened = createEvent<void>();

// view.tsx
const Component = () => {
  const click = useUnit(clickHappened);

  return (
    <div>
      <button onClick={() => click()}>click</button>
    </div>
  );
};
```

:::info{title="Events and frameworks"}
To call an event in UI code that uses a framework you need to access it through the `useUnit` hook.
:::

A **declarative** call happens when you connect one event to another with [`sample`](/en/api/effector/sample) and the [`target`](/en/api/effector/sample#target-argument) argument. The event passed into [`target`](/en/api/effector/sample#target-argument) will run whenever the [`clock`](/en/api/effector/sample#clock-argument) event fires:

```ts
import { createEvent, sample } from "effector";

const firstTriggered = createEvent<void>();
const secondTriggered = createEvent<void>();

sample({
  clock: firstTriggered,
  target: secondTriggered,
});
```

:::tip{title="Can I call sample imperatively?"}
The declarative way is the only correct approach when you work with `sample`. However, you can still call events imperatively [through `createAction`](/en/essentials/unit-composition#usage-of-operators) or inside an effect body.
:::

## Related API and docs (#related-api-and-docs-to-attach)

- **API**
  - [`Event API`](/en/api/effector/Event) — description of events, their methods, and properties
  - [`createEvent`](/en/api/effector/createEvent) — create a new event
  - [`sample`](/en/api/effector/sample) — the key operator for connecting units
  - [`Store API`](/en/api/effector/Store) — description of stores, their methods, and properties
- **Articles**
  - [How to think in the effector paradigm and why events matter](/en/resources/mindset)
  - [Typing events and other units](/en/essentials/typescript)
  - [How to glue units together with `sample` and `createAction`](/en/essentials/unit-composition)
